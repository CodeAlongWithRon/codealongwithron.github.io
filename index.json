[{
    "title": "Learn how to write testable code in C# in only 15 minutes",
    "date": "",
    "description": "In this course I will teach you how to write code that is easy to test and how to create the tests themselves. And even better: it will only take you 15 minutes!",
    "body": "Why you should want to unit test As an application grows, it becomes harder and harder to do manual testing. At some point the effort that goes into it simply becomes too much. The solution to this problem is automated testing. There are various types of automated tests, but in this course we will focus on unit tests.\nIn most cases unit tests are written by developers. Unit tests are called white box tests, because the developer knows the internal working of the application. The main benefit of unit tests is that they are very fast.\nTightly coupled code is not suited for unit testing One thing that is essential to unit testing is that the code must be written in a way that allows it to be tested. I will start off by showing an example of a class that was not written with testability in mind:\npublic class ApiMonitoringRepository\r{\rprivate static readonly HttpClient _httpClient = new HttpClient();\rpublic async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync()\r{\rvar response = await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;);\rif (response.IsSuccessStatusCode)\r{\rreturn HealthStatus.Healthy;\r}\rreturn HealthStatus.Unhealthy;\r}\r}\rpublic enum HealthStatus\r{\rHealthy,\rUnhealthy\r}\r What the method within this class does is performing a get request to an api. If the response status code is 2xx it returns a healthy status and otherwise it returns unhealthy. Pretty simple and purely looking at the functionality, it does what it\u0026rsquo;s supposed to do. But what if we want to create unit tests for the two existing scenario\u0026rsquo;s.\nBecause the class is tightly coupled to the HttpClient, it is impossible for us to have any control over the response of the get call. What we want to do, is move the execution of the get request to another class:\npublic class ApiMonitoringClient\r{\rprivate static readonly HttpClient _httpClient = new HttpClient();\rpublic async Task\u0026lt;HttpResponseMessage\u0026gt; GetResponseAsync()\r{\rreturn await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;);\r}\r}\r We can then update the ApiMonitoringRepository to make it call the ApiMonitoringClient instead of directly using the HttpClient:\npublic class ApiMonitoringRepository\r{\rprivate static readonly ApiMonitoringClient _client = new ApiMonitoringClient();\rpublic async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync()\r{\rvar response = await _client.GetResponseAsync();\rif (response.IsSuccessStatusCode)\r{\rreturn HealthStatus.Healthy;\r}\rreturn HealthStatus.Unhealthy;\r}\r}\r Although we have improved the separation of the code, we are still tightly coupled. Before the coupling was with the HttpClient and now it is with the newly created ApiMonitoringClient. One thing to look out for when searching for tight coupling, is the creation of new objects. Both in the current as in the previous version of the repository an instance of an object is created by using the new keyword.\nHow to make the code loosely coupled Now instead of creating an instance of the ApiMonitoringClient from within the repository, we will make use of dependency injection. In order to fully benefit from dependency injection, we want to make use of interfaces instead of concrete classes. Using interfaces makes it possible to supply mocks to the consumer of the interface. This gives us the control over the dependency that we are currently missing in our repository. The interface looks as follows:\npublic interface IApiMonitoringClient\r{\rTask\u0026lt;HttpResponseMessage\u0026gt; GetResponseAsync();\r}\r And the ApiMonitoringClient now implements the interface:\npublic class ApiMonitoringClient : IApiMonitoringClient\r We can now inject the newly created interface into the repository, resulting in the following variable and constructor changes:\nprivate readonly IApiMonitoringClient _client;\rpublic ApiMonitoringRepository(IApiMonitoringClient client)\r{\r_client = client;\r}\r If we created an actual application, we would have to register ApiMonitoringClient as the default implementation for the IApiMonitoringClient in a dependency injection container. Because the focus of this course is on unit testing, I will skip that part and continue with the creation of the unit tests.\nCreating the unit tests My favorite unit testing framework is XUnit and my mocking framework of choice is Moq. You will see these frameworks being used in the code examples below. For the repository there are two scenario\u0026rsquo;s that I would like to test:\n If the client returns a non success status code, does the repository return HealthStatus Unhealty? If the client returns a success status code, does the repository return HealthStatus Healthy?  The notation that I use for the name of my unit tests is as follows:\nSubjectUnderTest_TestScenario_ExpectedResult\r So in case of the first test scenario that I defined, I would name the test:\nIsHealthy_ClientResponseWithNonSuccessStatusCode_ReturnsUnhealthyStatus\r Next I start with following template for the test:\n[Fact]\rpublic async Task IsHealthy_ClientResponseWithSuccessStatusCode_ReturnsHealthyStatus()\r{\r// Arrange\r// Act\r// Assert\r}\r Fact is an attribute that tells the test runner that it is a test that should be run. Arrange is where we organise whatever is needed before we run our tests. Usually this involves the generation of mocks. Act is where we perform the test. And lastly Assert is where we verify that the outcome of the test matches the expectation that we have.\nWithout further ado, let\u0026rsquo;s create a unit test for our first test scenario:\n[Fact]\rpublic async Task IsHealthy_ClientResponseWithSuccessStatusCode_ReturnsHealthyStatus()\r{\r// Arrange\rvar client = new Mock\u0026lt;IApiMonitoringClient\u0026gt;();\rvar responseMessage = new HttpResponseMessage(HttpStatusCode.BadRequest);\rclient\r.Setup(c =\u0026gt; c.GetResponseAsync())\r.ReturnsAsync(responseMessage);\rvar repository = new ApiMonitoringRepository(client.Object);\r// Act\rvar result = await repository.IsHealthyAsync();\r// Assert\rAssert.Equal(HealthStatus.Unhealthy, result);\r}\r Arrange What we want to achieve with this test, is to see if the repository correctly handles different responses from the client. In order to do this, we want to have control over the response from the client. We get this control, by creating a mock for the client. Once we have the mock, we create the response message that we want it to return. Because we want to test the scenario of a non success status code, we create a response message with a Bad Request status code. Although I chose Bad Request in this example, any other non success status code (like Internal Server Error for example) would have led to the same result.\nNext we configure the mock by specifying which call we want to setup. In this case it is the GetResponseAsync method of the client. Then we specify what we want the method to return. That is the response message that we defined earlier.\nThe only thing remaining is to create an instance of the repository that we are testing. We do this by calling its constructor and providing the mock as argument.\nAct This one is easy. We simply execute the IsHealthyAsync method and assign its result to a variable.\nAssert Last but not least, we verify that the value of the result variable equals HealthStatus Unhealthy.\nRunning the test results in our first passed test!\nThe next test is up to you At this point, you should have enough knowledge to write a unit test for the second scenario. So instead of me showing you the code for this scenario, I would like to challenge you to write the test yourself. Think about the goal of the test, what you need to arrange to achieve this goal and then simply act and assert.\nFeel free to share the test you have written with me. I\u0026rsquo;m curious to see what you\u0026rsquo;ve managed to create!\nConclusion Obviously there is more to unit testing than what I provided in this course. Regardless of that you will be able to test the majority of your code with the tips and techniques you learned in this course. If you have questions regarding unit testing that have not been answered in this course, I would love for you to reach out to me in the comment section below.\n",
    "ref": "/blog/learn-how-to-write-testable-code-in-only-15-minutes/"
  },{
    "title": "Who am I?",
    "date": "",
    "description": "Let me introduce myself.",
    "body": "Hi! My name is Ron. I\u0026rsquo;m a 34 year old .net developer from the Netherlands. Throughout my career I have mainly done consultancy jobs, but currently I\u0026rsquo;m working as a full stack .net developer at a university.\nI first started coding before the age of ten and have been intrigued by it ever since. The skill to turn an idea into a working piece of software is something that I can get extremely enthusiastic about. In this blog I want to take you along with me as I work on various projects. My main goal is to share my knowledge with you, but also to learn from the feedback you provide. Coding is an endless learning journey and I would love to have you along the ride with me.\n",
    "ref": "/about/"
  },{
    "title": "You too can become a medior .net developer by following this course",
    "date": "",
    "description": "The goal of this course is to teach you how to evolve from a junior to a medior .net developer. I will create an application that keeps track of the popularity of a subreddit. The initial version of the code will be functional, but lacking any kind of design patterns. As I progress through the course, I will show you various ways to improve the code quality.",
    "body": "Table of contents Module 1: Creating a console app that prints a subreddit\u0026rsquo;s subscriber count\nModule 2: Creating a website that displays the subscriber count\nModule 3: Failing at unit testing and how to fix this\n",
    "ref": "/blog/you-too-can-become-medior-dotnet-developer-following-this-course/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
