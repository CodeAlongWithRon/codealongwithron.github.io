[{
    "title": "How to create a NuGet package and publish it using an automated build pipeline",
    "date": "",
    "description": "In this article I will teach you how to publish a NuGet package to nuget.org using an automated build pipeline in Azure DevOps.",
    "body": "Where we left off in the last post In the last post we created a library that allows us to unit test classes that use HttpClient. Now we want to make this library available for future projects, by creating a NuGet package. We finished the last post with a solution consisting of three projects:\n MockHttpClient PseudoClient PseudoClient.Tests  I have removed the two PseudoClient projects from the solution. As the name suggests they only contained pseudo code to prove that the core project worked. Afterwards I created a repository for the solution at GitHub and pushed the code to it.\nConsiderations to make when creating a NuGet package When you decide to create a NuGet package, it is important to think about the audience for your package. The work that you put into your package might be significantly less if you are the only one using it, compared to when you publish it to a public feed like nuget.org.\nWhen you add a package to nuget.org you might want to document your code, write a changelog and add a readme. If you are the only consumer of the package, the overhead is not worth the effort, because you know the internals of the code.\nDocumentation We are going to publish our library to nuget.org, so let\u0026rsquo;s take some time to think about how we want to inform users on how to use the library.\nDocumenting public classes and methods The first thing we should do, is to document the public classes and methods. The reason that we only write documentation for the public classes, is because only these classes will be exposed to users of the package.\nAdding a readme to the repository Another thing that I like to do for public repositories is to add a readme that lists the methods provided by the package and an example to go along with it.\nProviding support for dependency injection (DI) We created an abstraction over the declaration of HttpClient in our last post. For this we created the interface named ICustomHttpClientFactory and the implementation CustomHttpClientFactory. Because CustomHttpClientFactory is an internal class, we need to think about how we want to make it possible for users of the library to register the dependency.\nRegistering dependencies within the package When I create a private NuGet package at the company I work for, I add a DependencyRegistration class within the library itself. This class handles the registration of the dependency for the DI container we work with across all teams. The container we use is the default one that is part of .NET Core, so an example of DependencyRegistration would be like this:\npublic static class DependencyRegistration { public static void RegisterDependencies(IServiceCollection services) { services.AddSingleton\u0026lt;ICustomHttpClientFactory, CustomHttpClientFactory\u0026gt;(); } }  This is fine when you know that all the potential users of your package will be using the same DI container. In our current situation, where we publish a package to nuget.org, we have no idea of the DI container being used though. Therefore the example above would not suffice, because we would limit the package to users of the default .Net Core DI container.\nOne way to work around this would be to create specific registration methods for other DI containers. Although this would increase the amount of potential users, you still deny users that use a DI container for which you did not create a registration method. Also the creation of multiple registration methods is a tedious job that I am WAY to lazy for.\nRegistering dependencies outside the package Another solution is to make CustomHttpClientFactory public. This way we can shift the responsibility of registering the depency to the consumer of the package. The big advantage that it brings, is that it allows every user to use the library, regardless of the DI container they use. It also minimizes the work you have to do as creator of the package, because it is no longer required to create a dependency registration class.\nOne of the disadvantages is that the registration of the dependency is more error prone, because the user needs to do the registration. Another disadvantage is that the implementation of the interface will be exposed to the outside world. We usually want to avoid this, unless we have a good reason to expose it. So do we consider this scenario a good enough reason to make the implementation public? If you ask me, it sure is. Making implementations internal is not a religion, it is simply a good practice in a lot of scenario\u0026rsquo;s. In no way it is mandatory to always do this.\nWith that out of the way, let\u0026rsquo;s change the visibility modifier of CustomHttpClientFactory to public.\nDescribing the package Describing the package can be done by manually creating a nuspec file or by configuring the package properties. If prefer the latter of the two, because I find it the easiest. To do so, I right click the MockHttpClient project, select Properties and go to the Package tab. I will describe the properties that I set and the values that I provide for them.\nPackage id\nThe package id has to be a unique id for the feed that you are publishing to. I checked nuget.org and saw MockHttpClient was already taken, so instead I will use Cawr.MockHttpClient.\nPackage version\nFor now I will keep this at 0.1.0. This indicates that it\u0026rsquo;s a library that\u0026rsquo;s still in the early stages of development. Later on in this article I will describe how I handle versioning of packages.\nAuthors\nRon\nCompany\nCodeAlongWithRon\nProduct\nI keep this in line with the name of the project, so in this case MockHttpClient.\nDescription\nThis is were we describe what the package does. I came up with the following description: MockHttpClient makes it possible to mock the HttpResponseMessage that is returned by HttpClient. This allows you to unit test classes that use HttpClient.\nRepository URL\nhttps://github.com/CodeAlongWithRon/MockHttpClient\nRepository type\nGit\nTags\nThis is a space-delimited list of tags to describe the package. In this case: httpclient mock mocking unittest unittesting\nRelease notes\nHere we describe the changes we added in this release. Because it is our first version I will simply write First version.\nRegistering an api key at nuget.org For our automated pipeline to be able to push a package to nuget.org, we have to make sure it is authorized. To perform the authorization, we need an API key from nuget.org. To create one, we go to nuget.org and sign in with a Microsoft account. Once we are logged in, we click our user name in the top right corner and go to API Keys.\nIf we click Create, we get to configure the key. The only thing we have to set is the Key Name and the Glob Pattern. The other default settings are fine. The key name we will use is AzureDevopsKey and for the Glob Pattern I will use *. The asterisk means that the api key will be able to perform the selected scopes for all packages. Once the key is created, make sure to copy it, because once that page is closed it will no longer be available.\nSetting up a build pipeline in Azure DevOps For my automated build and release pipelines I use Azure DevOps. I already have an organisation named CodeAlongWithRon and also a project named Nuget packages. For the creation of the NuGet package we only create a build pipeline, so that is where our focus will be.\nAuthorizing Azure DevOps to push packages to nuget.org Before we begin with the creation of a pipeline, let\u0026rsquo;s create a service connection so our pipeline will be authorized to access nuget.org. To do this, go to the project settings (see the black rectangle for the location of the link):\nWe go to service connections, which is listed under the Pipelines header. Then we create a new service connection and select NuGet from the list.\nWe select ApiKey as the authentication method and use the provide the following Feed URL: https://api.nuget.org/v3/index.json. In the ApiKey input field we paste the key we generated at nuget.org and the last thing we do is to provide a name for the service connection. I will simply name it CodeAlongWithRonNuget.\nCreating the pipeline Now that we have the service connection in place, let\u0026rsquo;s continue with the creation of the pipeline. Because we do not yet have any pipeline, we see the following screen:\nClicking the Create Pipeline button allows us to specify where the code is hosted, which is GitHub in our case. We now have to grant the pipeline access to the GitHub repository:\nAfter clicking the Authorize AzurePipelines button, we have to enter the password for the GitHub account and then we can select the repository we want to grant access to. We select CodeAlongWithRon/MockHttpClient and walk through the next authorization steps in the flow.\nNext we get to see the Configure your pipeline step, where we select Starter pipeline. We are now able to configure the steps that we want the pipeline to perform. In our case we want the following steps to be performed:\n Build the solution Create the package Publish the package  This results in the following YAML file:\n# If a commit is pushed to the main branch of the Git repository, this build will automatically run trigger: - main # Run this pipeline on a build agent containing the latest version of ubuntu pool: vmImage: 'ubuntu-latest' # Here we define variables that we want to use variables: buildConfiguration: 'Release' steps: # Builds a release version of all projects that exist in a subfolder of the root folder - task: DotNetCoreCLI@2 inputs: command: 'build' projects: '**/*.csproj' arguments: '--configuration $(buildConfiguration)' displayName: 'Build projects' # Creates a nuget package for all projects that exist in a subfolder of the root folder, except for test projects - task: DotNetCoreCLI@2 inputs: command: 'pack' packagesToPack: '**/*.csproj;!**/*.Tests.csproj' versioningScheme: 'off' displayName: 'Create package' # Pushes all nuget packages that were created to nuget.org and uses the service connection named CodeAlongWithRonNuget to do so - task: NuGetCommand@2 inputs: command: 'push' packagesToPush: '$(Build.ArtifactStagingDirectory)/*.nupkg;!$(Build.ArtifactStagingDirectory)/*.symbols.nupkg' nuGetFeedType: 'external' publishFeedCredentials: 'CodeAlongWithRonNuget' displayName: 'Push package to nuget.org'  Now that the pipeline is configured, we can save and run the pipeline to push the package to nuget.org and the private feed. In the dialog that appears we can decide whether we want to push the YAML file to the main branch or if we want to create a new branch based on the main branch. Let\u0026rsquo;s simply choose to add the file to the main branch and then wait for the pipeline to run. After a bit of waiting, we see that the pipeline successfully ran and that the package was added to both feeds.\nAdding new functionality to the package Now let\u0026rsquo;s say we want to add some more overloads for the Create method of MockHttpClientFactory:\nThe implementation looks like this:\npublic static HttpClient Build(HttpStatusCode statusCode, string responseString) { var responseMessage = new HttpResponseMessage { Content = new StringContent(responseString), StatusCode = statusCode }; return Build(responseMessage); } public static HttpClient Build\u0026lt;T\u0026gt;(HttpStatusCode statusCode, T responseObject) { try { var responseString = JsonConvert.SerializeObject(responseObject); return Build(statusCode, responseString); } catch (JsonSerializationException) { throw new ArgumentException(\u0026quot;The provided response object could not be serialized.\u0026quot;); } }  Versioning the package Now that we have an updated version of the library, we want to publish it to the NuGet feeds again. To do this, we are required to update the package version in the project properties. We also want to update the release notes, so users of our library get to know about the changes in this version. But before we move to the release notes, let\u0026rsquo;s first take some time to think about how we want to deal with the versioning of the package.\nLet\u0026rsquo;s start by stating that there are a lot of ways to handling versioning. Stating that one specific way is the good way and all others are the incorrect way is ignorant. The versioning system that I prefer is semantic versioning where we work with major.minor.patch. Our current version 0.1.0 is also created according to this system. But when do we update which number?\nIf we have only done backward compatible bug fixes and did not add any new functionality, we increase the revision number by one. If we added new functionality that is backward compatible, we increase the minor number by one. If we introduced breaking changes, we increase the major number by one. Another scenario where we increase the major is if we go from a beta version to a release version.\nBecause we added new functionality that is backward compatible, we will up the minor, so our new version number will be 0.2.0.\nFor the release notes we\u0026rsquo;ll write: Added new overloads for the Create method to MockHttpClientFactory so we can easily provide a response string or object.\nLastly we also need to update the readme, so it contains the newly created overloads.\nPublishing the updated library Now that we have updated our library, we want to push it to our NuGet feeds again. Because the automated build pipeline is in place, the only thing we need to do is to push our commit to the main branch. This will trigger the pipeline and results in the new version being published to the feeds.\nConclusion With the lessons you learned in this post, you should now be able to create and manage your own NuGet packages. If you have any questions or comments, do not hesitate to ask them in the comments below. Also if you created you own public NuGet package, feel free to share it. I am very interested to see what you have created!\n",
    "ref": "/blog/create-nuget-package/"
  },{
    "title": "Creating a library to unit test classes that use an HttpClient",
    "date": "",
    "description": "Unit testing classes that use an HttpClient can be a pain. Along the years I've seen various ways of dealing with this pain: varying from the creation of custom wrappers over HttpClient to not testing these classes at all. In this course I will show you there's a pretty easy way to achieve this by gaining an understanding of how the HttpClient was created and how to make use of that.",
    "body": "Let\u0026rsquo;s very briefly start with the basics of unit testing: in order to effectively write unit tests, we want our classes to be loosely coupled. To achieve loose coupling, we make use of dependency injection. To learn more about writing testable code, make sure to read my post Learn how to write testable code in C# in only 15 minutes.\nAn abstraction over the declaration of HttpClient Because we want to prevent tight coupling to HttpClient, we will need an abstraction over it. This way we can inject the abstraction in the constructor, which allows us to replace it with a mock for our unit tests.\nIf you will be working with .NET Core 2.1 or a newer version of .NET Core it is not required to create a custom abstraction. The IHttpClientFactory is perfectly suited:\nCreating a custom HttpClient factory If you do not use .NET Core or if you use an older version than 2.1 we are required create our own abstraction. Let\u0026rsquo;s keep this in line with IHttpClientFactory:\nFor the implementation we want to create a static instance of HttpClient (if you would like to know why this needs to be static, make sure to read You\u0026rsquo;ve been using HttpClient incorrectly). This instance will then be return by the CreateClient method.\ninternal class CustomHttpClientFactory : ICustomHttpClientFactory { private static readonly HttpClient _httpClient = new HttpClient(); public HttpClient CreateClient() { return _httpClient; } }  We can use a mocking framework of choice to create a mock for the I(Custom)HttpClientFactory. We can then provide an HttpClient from the unit test to the setup for the mock\u0026rsquo;s CreateClient method. By doing so we have control over the HttpClient that gets returned.\nGetting control over the response from HttpClient So far so good, but how do we get control over the HttpResponseMessage that is returned by the various REST methods of the HttpClient? To find this out, we need to know about the internals of the HttpClient.\nAs you can see in the class diagram above, HttpClient contains two constructors: one parameterless constructor and one constructor that takes an input parameter of type HttpMessageHandler.\nIf the parameterless constructor is called, an instance of an HttpClientHandler is created internally. This is then passed to the other constructor, which is possible because HttpClientHandler extends HttpMessageHandler. Eventually the handler is passed to the HttpMessageInvoker and that is where the handler is executed and the HttpResponseMessage is returned.\nThe HttpClientHandler performs the actual web requests. Because we do not want the web requests to be performed for our unit tests, we know the parameterless constructor is not suitable to get control over the returned HttpResponseMessage.\nBut what if we create a custom implementation of an HttpMessageHandler and provide that to the HttpClient? The HttpMessageHandler class looks as follows:\nThis is something that we can work with! We simply have to override the SendAsync method and make it return an HttpResponseMessage. The response message can be provided through the constructor and then be returned by SendAsync.\nImplementing the MockHttpMessageHandler Now that we have a clear view of what we want to achieve and how we want to do it, let\u0026rsquo;s start writing some code. Let\u0026rsquo;s begin with the MockHttpMessageHandler that we just modeled:\npublic class MockHttpMessageHandler : HttpMessageHandler { private readonly HttpResponseMessage _httpResponseMessage; public MockHttpMessageHandler(HttpResponseMessage httpResponseMessage) { _httpResponseMessage = httpResponseMessage; } protected override Task\u0026lt;HttpResponseMessage\u0026gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { return Task.FromResult(_httpResponseMessage); } }  Creating a unit test Everything is in place now to test a class that uses an HttpClient. Let\u0026rsquo;s say we want to test the following class:\npublic class PseudoCodeClient { private readonly ICustomHttpClientFactory _httpClientFactory; public PseudoCodeClient(ICustomHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task\u0026lt;bool\u0026gt; ReturnsOkResponseAsync() { var client = _httpClientFactory.CreateClient(); var response = await client.GetAsync(\u0026quot;http://www.api.com\u0026quot;); return response.IsSuccessStatusCode; } }  You can see that it performs a GET request to an api using the client that is created by the factory. Lastly it returns whether or not the response has a success status code. Pretty straightforward, but suitable nonetheless to test if we can get control over the response from HttpClient. Let\u0026rsquo;s start with the creation of a unit test that checks if true is returned if the response has a success status code:\n[Fact] public async Task ReturnsOkResponse_ClientReturnsOkResponse_ReturnsTrue() { // Arrange var factory = new Mock\u0026lt;ICustomHttpClientFactory\u0026gt;(); var messageHandler = new MockHttpMessageHandler(new HttpResponseMessage(HttpStatusCode.OK)); var httpClient = new HttpClient(messageHandler); factory .Setup(f =\u0026gt; f.CreateClient()) .Returns(httpClient); var client = new PseudoCodeClient(factory.Object); // Act var result = await client.ReturnsOkResponseAsync(); // Assert Assert.True(result); }  If we disect that arrange part of the test, we see that we start with the creation of a mock for ICustomHttpClientFactory. I use Moq for the creation of mocks, but there are various alternatives that you could also use. We then create an instance of our MockHttpMessageHandler and pass this to the constructor of the HttpClient. What follows is the setup of the CreateClient method so it returns the HttpClient. Lastly we create an instance of PseudoCodeClient, injecting the mock into its constructor.\nThe scenario where we test if false is returned if a non success status code is returned by HttpClient is pretty similar:\n[Fact] public async Task ReturnsOkResponse_ClientReturnsBadRequestResponse_ReturnsFalsee() { // Arrange var factory = new Mock\u0026lt;ICustomHttpClientFactory\u0026gt;(); var messageHandler = new MockHttpMessageHandler(new HttpResponseMessage(HttpStatusCode.BadRequest)); var httpClient = new HttpClient(messageHandler); factory .Setup(f =\u0026gt; f.CreateClient()) .Returns(httpClient); var client = new PseudoCodeClient(factory.Object); // Act var result = await client.ReturnsOkResponseAsync(); // Assert Assert.False(result); }  Improving the user friendliness Although we have achieved our main goal of being able to unit test classes that use an HttpClient, the way it is done is not really user friendly. For every test an instance of MockHttpMessageHandler has to be created, with an instance of HttpResponseMessage in its constructor and then it needs to be passed to the HttpClient. Wouldn\u0026rsquo;t it be better to create a factory that helps us with the creation of HttpClients? In PseudoCodeClient we are only interested in the status code of the response. What if we would add a method to the factory that takes a status code as input, and let the factory create the HttpClient internally?\nNow we provide the user with the flexibility to provide an HttpResponseMessage, but also to simply provide an HttpStatusCode. The code looks like this:\npublic static class MockHttpClientFactory { public static HttpClient Build(HttpResponseMessage responseMessage) { return new HttpClient(new MockHttpMessageHandler(responseMessage)); } public static HttpClient Build(HttpStatusCode statusCode) { return Build(new HttpResponseMessage(statusCode)); } }  Now we can refactor the unit tests so they use the MockHttpClientFactory:\n[Fact] public async Task ReturnsOkResponse_ClientReturnsOkResponse_ReturnsTrue() { // Arrange var httpClient = MockHttpClientFactory.Create(HttpStatusCode.OK); factory .Setup(f =\u0026gt; f.CreateClient()) .Returns(httpClient); var client = new PseudoCodeClient(factory.Object); // Act var result = await client.ReturnsOkResponseAsync(); // Assert Assert.True(result); }  That is more like it. Compact, easy and thus user friendly. Let\u0026rsquo;s add a couple more overloads, so we can also easily provide a response string and a response object:\npublic static HttpClient Build(HttpStatusCode statusCode, string responseString) { var responseMessage = new HttpResponseMessage { Content = new StringContent(responseString), StatusCode = statusCode }; return Build(responseMessage); } public static HttpClient Build\u0026lt;T\u0026gt;(HttpStatusCode statusCode, T responseObject) { try { var responseString = JsonConvert.SerializeObject(responseObject); return Build(statusCode, responseString); } catch (JsonSerializationException) { throw new ArgumentException(\u0026quot;The provided response object could not be serialized.\u0026quot;); } }  Wrapping things up And there we have it: a user friendly library to test classes that use HttpClient. To really make it usable, we will need to create a NuGet package for it. That way we can easily incorporate it within various unit testing projects. In my next post I will show you how to create a NuGet package and how to publish it to both nuget.org and to a custom NuGet feed. I will do this by setting up an automated build pipeline. Make sure you stay tuned for the next post!\n",
    "ref": "/blog/creating-library-unit-test-classes-that-use-httpclient/"
  },{
    "title": "You've been using the HttpClient incorrectly",
    "date": "",
    "description": "Regardless of the project that you are working on, I am sure that at one point or another you have used an HttpClient. Another thing that I am sure of is that you have been using it incorrectly. Let me show you the correct way of using the HttpClient.",
    "body": "Why we use the HttpClient incorrectly The HttpClient is being misused as often as it is, because of two reasons:\n We\u0026rsquo;ve been taught to instantiate disposable objects in a using statement The majority of the tutorials teach us the wrong way  Manually disposing is a no-go If we look at the HttpClient class, we see that it extends the HttpMessageInvoker class which in turn implements IDisposable. One thing that we learn at a pretty early stage as C# developers is that disposable objects need to be instantiated within a using statement. Doing this ensures that the object is disposed once we break out of the using statement. Although this is a good practice in the majority of situations, the HttpClient is an exception to this rule. To quote the official documentation:\n HttpClient is intended to be instantiated once and re-used throughout the life of an application. Instantiating an HttpClient class for every request will exhaust the number of sockets available under heavy loads. This will result in SocketException errors.\n If you are reading this and thinking to yourself \u0026ldquo;Ha! I am using HttpClient correctly\u0026rdquo;, can I safely assume that you have experienced these errors first hand? I sure know I did :-)\nWe are taught the wrong way The other reason the HttpClient is used incorrectly, is simply because we are taught to use it the wrong way. If you Google C# HttpClient tutorial the first two (non Microsoft) results teach to instantiate it within a using statement. That leads to people learning the incorrect way to use an HttpClient and they may teach a colleague or friend about this way and so on\u0026hellip;\nLet\u0026rsquo;s break this vicious circle by learning how to use the HttpClient correctly!\nThe correct way to use an HttpClient Now that we\u0026rsquo;ve seen how not to use the HttpClient, let\u0026rsquo;s shift our focus to the correct way of using it. There are two options that I would like to describe.\nOption 1: Assigning the HttpClient to a static field One way to use the HttpClient correctly is by assigning it to a static field. This way it adheres to the principal of instantiating it once and then re-using it throughout the life of an application. For example:\npublic class ApiMonitoringRepository { private static readonly HttpClient _httpClient = new HttpClient(); public async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync() { var response = await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;); } }  Option 2: Using .NET Core\u0026rsquo;s IHttpClientFactory Although the above example works fine and will not lead to the exhaustion of sockets, there is another option and that is the option that I prefer. I\u0026rsquo;m talking about the IHttpClientFactory that is part of .NET Core since version 2.1. This factory manages the lifecycle of HttpMessageHandler and thus avoids the socket issue.\nThe following example shows how to create an HttpClient using the IHttpClientFactory:\npublic class ApiMonitoringRepository { private readonly IHttpClientFactory _factory; public ApiMonitoringRepository(IHttpClientFactory factory) { _factory = factory; } public async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync() { var client = _factory.CreateClient(); var response = await client.GetAsync(\u0026quot;https://www.api.com\u0026quot;); } }  As you see in the example above, we are no longer instantiating an HttpClient, but we are injecting the IHttpClientFactory through the constructor. Because of this we are no longer tightly coupled to the HttpClient, which allows us to more effectively unit test our class.\nBeware: To use the IHttpClientFactory you need to register it in your dependency injection (DI) container. If you use .NET Core\u0026rsquo;s default DI container, you you can do so like this:\npublic class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddHttpClient(); // Remaining code deleted for brevity.  Besides the prevention of socket exhaustion and the possibility to use dependency injection, the IHttpClientFactory also provides other benefits. These benefits are outside the scope of this post, but if you would like to learn more I would suggest you to read the article Use IHttpClientFactory to implement resilient HTTP requests.\nConclusion The creation of a new HttpClient for every request is a flaw that can remain unnoticed for a long time. Applications with small loads may have been doing it for years, without ever experiencing problems. Just remember that once the load starts to increase, it is only a matter of time before the SocketExceptions start to appear. Be smart and correct the lifecycle management of your HttpClient. It is not difficult to do, it does not take much time and it will save you a lot of headache.\n",
    "ref": "/blog/youve-been-using-the-httpclient-incorrectly/"
  },{
    "title": "Learn how to write testable code in C# in only 15 minutes",
    "date": "",
    "description": "In this course I will teach you how to write code that is easy to test and how to create the tests themselves. And even better: it will only take you 15 minutes!",
    "body": "Why you should want to unit test As an application grows, it becomes harder and harder to do manual testing. At some point the effort that goes into it simply becomes too much. The solution to this problem is automated testing. There are various types of automated tests, but in this course we will focus on unit tests.\nIn most cases unit tests are written by developers. Unit tests are called white box tests, because the developer knows the internal working of the application. The main benefit of unit tests is that they are very fast.\nTightly coupled code is not suited for unit testing One thing that is essential to unit testing is that the code must be written in a way that allows it to be tested. I will start off by showing an example of a class that was not written with testability in mind:\npublic class ApiMonitoringRepository\r{\rprivate static readonly HttpClient _httpClient = new HttpClient();\rpublic async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync()\r{\rvar response = await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;);\rif (response.IsSuccessStatusCode)\r{\rreturn HealthStatus.Healthy;\r}\rreturn HealthStatus.Unhealthy;\r}\r}\rpublic enum HealthStatus\r{\rHealthy,\rUnhealthy\r}\r What the method within this class does is performing a get request to an api. If the response status code is 2xx it returns a healthy status and otherwise it returns unhealthy. Pretty simple and purely looking at the functionality, it does what it\u0026rsquo;s supposed to do. But what if we want to create unit tests for the two existing scenario\u0026rsquo;s.\nBecause the class is tightly coupled to the HttpClient, it is impossible for us to have any control over the response of the get call. What we want to do, is move the execution of the get request to another class:\npublic class ApiMonitoringClient\r{\rprivate static readonly HttpClient _httpClient = new HttpClient();\rpublic async Task\u0026lt;HttpResponseMessage\u0026gt; GetResponseAsync()\r{\rreturn await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;);\r}\r}\r We can then update the ApiMonitoringRepository to make it call the ApiMonitoringClient instead of directly using the HttpClient:\npublic class ApiMonitoringRepository\r{\rprivate static readonly ApiMonitoringClient _client = new ApiMonitoringClient();\rpublic async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync()\r{\rvar response = await _client.GetResponseAsync();\rif (response.IsSuccessStatusCode)\r{\rreturn HealthStatus.Healthy;\r}\rreturn HealthStatus.Unhealthy;\r}\r}\r Although we have improved the separation of the code, we are still tightly coupled. Before the coupling was with the HttpClient and now it is with the newly created ApiMonitoringClient. One thing to look out for when searching for tight coupling, is the creation of new objects. Both in the current as in the previous version of the repository an instance of an object is created by using the new keyword.\nHow to make the code loosely coupled Now instead of creating an instance of the ApiMonitoringClient from within the repository, we will make use of dependency injection. In order to fully benefit from dependency injection, we want to make use of interfaces instead of concrete classes. Using interfaces makes it possible to supply mocks to the consumer of the interface. This gives us the control over the dependency that we are currently missing in our repository. The interface looks as follows:\npublic interface IApiMonitoringClient\r{\rTask\u0026lt;HttpResponseMessage\u0026gt; GetResponseAsync();\r}\r And the ApiMonitoringClient now implements the interface:\npublic class ApiMonitoringClient : IApiMonitoringClient\r We can now inject the newly created interface into the repository, resulting in the following variable and constructor changes:\nprivate readonly IApiMonitoringClient _client;\rpublic ApiMonitoringRepository(IApiMonitoringClient client)\r{\r_client = client;\r}\r If we created an actual application, we would have to register ApiMonitoringClient as the default implementation for the IApiMonitoringClient in a dependency injection container. Because the focus of this course is on unit testing, I will skip that part and continue with the creation of the unit tests.\nCreating the unit tests My favorite unit testing framework is XUnit and my mocking framework of choice is Moq. You will see these frameworks being used in the code examples below. For the repository there are two scenario\u0026rsquo;s that I would like to test:\n If the client returns a non success status code, does the repository return HealthStatus Unhealty? If the client returns a success status code, does the repository return HealthStatus Healthy?  The notation that I use for the name of my unit tests is as follows:\nSubjectUnderTest_TestScenario_ExpectedResult\r So in case of the first test scenario that I defined, I would name the test:\nIsHealthy_ClientResponseWithNonSuccessStatusCode_ReturnsUnhealthyStatus\r Next I start with following template for the test:\n[Fact]\rpublic async Task IsHealthy_ClientResponseWithSuccessStatusCode_ReturnsHealthyStatus()\r{\r// Arrange\r// Act\r// Assert\r}\r Fact is an attribute that tells the test runner that it is a test that should be run. Arrange is where we organise whatever is needed before we run our tests. Usually this involves the generation of mocks. Act is where we perform the test. And lastly Assert is where we verify that the outcome of the test matches the expectation that we have.\nWithout further ado, let\u0026rsquo;s create a unit test for our first test scenario:\n[Fact]\rpublic async Task IsHealthy_ClientResponseWithSuccessStatusCode_ReturnsHealthyStatus()\r{\r// Arrange\rvar client = new Mock\u0026lt;IApiMonitoringClient\u0026gt;();\rvar responseMessage = new HttpResponseMessage(HttpStatusCode.BadRequest);\rclient\r.Setup(c =\u0026gt; c.GetResponseAsync())\r.ReturnsAsync(responseMessage);\rvar repository = new ApiMonitoringRepository(client.Object);\r// Act\rvar result = await repository.IsHealthyAsync();\r// Assert\rAssert.Equal(HealthStatus.Unhealthy, result);\r}\r Arrange What we want to achieve with this test, is to see if the repository correctly handles different responses from the client. In order to do this, we want to have control over the response from the client. We get this control, by creating a mock for the client. Once we have the mock, we create the response message that we want it to return. Because we want to test the scenario of a non success status code, we create a response message with a Bad Request status code. Although I chose Bad Request in this example, any other non success status code (like Internal Server Error for example) would have led to the same result.\nNext we configure the mock by specifying which call we want to setup. In this case it is the GetResponseAsync method of the client. Then we specify what we want the method to return. That is the response message that we defined earlier.\nThe only thing remaining is to create an instance of the repository that we are testing. We do this by calling its constructor and providing the mock as argument.\nAct This one is easy. We simply execute the IsHealthyAsync method and assign its result to a variable.\nAssert Last but not least, we verify that the value of the result variable equals HealthStatus Unhealthy.\nRunning the test results in our first passed test!\nThe next test is up to you At this point, you should have enough knowledge to write a unit test for the second scenario. So instead of me showing you the code for this scenario, I would like to challenge you to write the test yourself. Think about the goal of the test, what you need to arrange to achieve this goal and then simply act and assert.\nFeel free to share the test you have written with me. I\u0026rsquo;m curious to see what you\u0026rsquo;ve managed to create!\nConclusion Obviously there is more to unit testing than what I provided in this course. Regardless of that you will be able to test the majority of your code with the tips and techniques you learned in this course. If you have questions regarding unit testing that have not been answered in this course, I would love for you to reach out to me in the comment section below.\n",
    "ref": "/blog/learn-how-to-write-testable-code-in-only-15-minutes/"
  }]
