[{
    "title": "You've been using the HttpClient incorrectly",
    "date": "",
    "description": "Regardless of the project that you are working on, I am sure that at one point or another you have used an HttpClient. Another thing that I am sure of is that you have been using it incorrectly. Let me show you the correct way of using the HttpClient.",
    "body": "Why the HttpClient confuses us The reason that the HttpClient is being misused as often as it is, is because of two reasons:\n We\u0026rsquo;ve been taught to instantiate disposable objects in a using statement The majority of the tutorials teach us the wrong way  Manually disposing is a no-go If we look at the HttpClient class, we see that it extends the HttpMessageInvoker class which in turn implements IDisposable. One thing that we learn at a pretty early stage as C# developers is that disposable objects need to be instantiated within a using statement. Doing this ensures that the object is disposed once we break out of the using statement. Although this is a good practice in the majority of situations, the HttpClient is an exception to this rule. To quote the official documentation:\n HttpClient is intended to be instantiated once and re-used throughout the life of an application. Instantiating an HttpClient class for every request will exhaust the number of sockets available under heavy loads. This will result in SocketException errors.\n If you are reading this and thinking to yourself \u0026ldquo;Ha! I am using HttpClient correctly\u0026rdquo;, can I safely assume that you have experienced these errors first hand? I sure know I did :-)\nWe are taught the wrong way The other reason the HttpClient is used incorrectly, is simply because we are taught to use it the wrong way. If you Google C# HttpClient tutorial the first two (non Microsoft) results teach to instantiate it within a using statement. That leads to people learning the incorrect way to use an HttpClient and they may teach a colleague or friend about this way and so on\u0026hellip;\nLet\u0026rsquo;s break this vicious circle by learning how to use the HttpClient correctly!\nThe correct way to use an HttpClient Now that we\u0026rsquo;ve seen how not to use the HttpClient, let\u0026rsquo;s shift our focus to the correct way of using it. There are two options that I would like to describe.\nOption 1: Assigning the HttpClient to a static field One way to use the HttpClient correctly is by assigning it to a static field. This way it adheres to the principal of instantiating it once and then re-using it throughout the life of an application. For example:\npublic class ApiMonitoringRepository { private static readonly HttpClient _httpClient = new HttpClient(); public async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync() { var response = await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;); } }  Option 2: Using .NET Core\u0026rsquo;s IHttpClientFactory Although the above example works fine and will not lead to the exhaustion of sockets, there is another option and that is the option that I prefer. I\u0026rsquo;m talking about the IHttpClientFactory that is part of .NET Core since version 2.1. This factory manages the lifecycle of HttpMessageHandler and thus avoids the socket issue.\nThe following example shows how to create an HttpClient using the IHttpClientFactory:\npublic class ApiMonitoringRepository { private readonly IHttpClientFactory _factory; public ApiMonitoringRepository(IHttpClientFactory factory) { _factory = factory; } public async Task\u0026lt;HealthStatus\u0026gt; IsHealthyAsync() { var client = _factory.CreateClient(); var response = await _httpClient.GetAsync(\u0026quot;https://www.api.com\u0026quot;); } }  As you see in the example above, we are no longer instantiating an HttpClient, but we are injecting the IHttpClientFactory through the constructor. Because of this we are no longer tightly coupled to the HttpClient, which allows us to more effectively unit test our class.\nBeware: To use the IHttpClientFactory you need to register it in your dependency injection (DI) container. If you use .NET Core\u0026rsquo;s default DI container, you you can do so like this:\npublic class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.AddHttpClient(); // Remaining code deleted for brevity.  Besides the prevention of socket exhaustion and the possibility to use dependency injection, the IHttpClientFactory also provides other benefits. These benefits are outside the scope of this post, but if you would like to learn more I would suggest you to read the article Use IHttpClientFactory to implement resilient HTTP requests.\nConclusion The creation of a new HttpClient for every request is a flaw that can remain unnoticed for a long time. Applications with small loads may have been doing it for years, without ever experiencing problems. Just remember that once the load starts to increase, it is only a matter of time before the SocketExceptions start to appear. Be smart and correct the lifecycle management of your HttpClient. It is not difficult to do, it does not take much time and it will save you a lot of headache.\n",
    "ref": "/blog/youve-been-using-the-httpclient-incorrectly/"
  }]
